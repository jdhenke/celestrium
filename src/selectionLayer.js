// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['jquery', 'underscore', 'backbone', 'd3'], function($, _, Backbone, d3) {
    var SelectionLayer;
    return SelectionLayer = (function() {
      function SelectionLayer(args) {
        this._clearRect = __bind(this._clearRect, this);
        this._drawRect = __bind(this._drawRect, this);
        this.rectDim = __bind(this.rectDim, this);
        this.renderRect = __bind(this.renderRect, this);
        this._updateCurrentPoint = __bind(this._updateCurrentPoint, this);
        this._setStartPoint = __bind(this._setStartPoint, this);
        this.parent = args.parent;
        this.$parent = $(this.parent);
        _.extend(this, Backbone.Events);
        this._initializeDragVariables();
        this.render();
      }

      SelectionLayer.prototype.render = function() {
        this.canvas = $('<canvas/>').addClass('selectionLayer').css('position', 'absolute').attr('width', $('body').width()).attr('height', $('body').height()).css('top', 0).css('left', 0).css('margin', '8px').css('pointer-events', 'none')[0];
        this.$parent.append(this.canvas);
        return this._registerMouseEvents();
      };

      SelectionLayer.prototype._initializeDragVariables = function() {
        this.dragging = false;
        this.startPoint = {
          x: 0,
          y: 0
        };
        this.prevPoint = {
          x: 0,
          y: 0
        };
        return this.currentPoint = {
          x: 0,
          y: 0
        };
      };

      SelectionLayer.prototype._setStartPoint = function(coord) {
        this.startPoint.x = coord.x;
        return this.startPoint.y = coord.y;
      };

      SelectionLayer.prototype._updateCurrentPoint = function(coord) {
        this.currentPoint.x = e.pageX;
        return this.currentPoint.y = e.pageY;
      };

      SelectionLayer.prototype._registerMouseEvents = function() {
        var _this = this;
        this.$parent.mousedown(function(e) {
          if (e.shiftKey) {
            _this.dragging = true;
            _.extend(_this.startPoint, {
              x: e.pageX,
              y: e.pageY
            });
            return false;
          }
        });
        this.$parent.mousemove(function(e) {
          if (e.shiftKey) {
            if (_this.dragging) {
              _.extend(_this.prevPoint, _this.currentPoint);
              _.extend(_this.currentPoint, {
                x: e.pageX,
                y: e.pageY
              });
              _this.renderRect();
              /*
                  TODO
                  We can decide to use this to select nodes
                  i.e. calculate what nodes are in our rect and select them
              */

              return false;
            }
          }
        });
        this.$parent.mouseup(function(e) {
          _this.dragging = false;
          /*
              TODO
              Another option is to zoom to rect on release
              Should this rectangle persist on mouse release? depends...
          
              what's the best option in terms of usability?
          */

          _this._clearRect(_this.startPoint, _this.currentPoint);
          _.extend(_this.startPoint, {
            x: 0,
            y: 0
          });
          return _.extend(_this.currentPoint, {
            x: 0,
            y: 0
          });
        });
        return $(window).keyup(function(e) {
          if (e.keyCode === 16) {
            _this.dragging = false;
            _this._clearRect(_this.startPoint, _this.prevPoint);
            return _this._clearRect(_this.startPoint, _this.currentPoint);
          }
        });
      };

      SelectionLayer.prototype.renderRect = function() {
        this._clearRect(this.startPoint, this.prevPoint);
        return this._drawRect(this.startPoint, this.currentPoint);
      };

      SelectionLayer.prototype.rectDim = function(startPoint, endPoint) {
        var dim;
        dim = {};
        dim.x = startPoint.x < endPoint.x ? startPoint.x : endPoint.x;
        dim.y = startPoint.y < endPoint.y ? startPoint.y : endPoint.y;
        dim.width = Math.abs(startPoint.x - endPoint.x);
        dim.height = Math.abs(startPoint.y - endPoint.y);
        return dim;
      };

      SelectionLayer.prototype._drawRect = function(startPoint, endPoint) {
        var ctx, dim;
        dim = this.rectDim(startPoint, endPoint);
        ctx = this.canvas.getContext('2d');
        ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
        return ctx.fillRect(dim.x, dim.y, dim.width, dim.height);
      };

      SelectionLayer.prototype._clearRect = function(startPoint, endPoint) {
        var ctx, dim;
        dim = this.rectDim(startPoint, endPoint);
        ctx = this.canvas.getContext('2d');
        return ctx.clearRect(dim.x, dim.y, dim.width, dim.height);
      };

      return SelectionLayer;

    })();
  });

}).call(this);
